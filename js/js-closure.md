## JS 重要概念之闭包

> 前面讲了执行上下文与作用域，而闭包是和它们是密切相关，通过之前的概念，我们应该可以很好的理解闭包了。

我们知道，局部作用域访问外层的作用域是轻而易举的事情，因为我们的作用域链会首先加入上层的作用域链，即在函数内部可以访问得到外部的变量。而如果我们想在函数外部访问这个函数的变量时，那就没那么简单了。不过可以通过我们今天的主角来实现。

所以这就是闭包的作用。那闭包怎么构建出来的呢？其实这也非常简单，通过内部函数可以访问外层函数的变量就可以实现：

<pre>
<code>
function outer(){
  var a = 0;
  return function(){console.log(a++);}
}
var f = outer();
f();
</code>
</pre>

在函数outer中我们定义了一个函数然后返回它。而这个内部函数访问了a，这个在outer的作用域内找到了，所以内部函数的a引用了外部函数的a。这样的话，当我们执行完外部函数，得到了一个内部函数，因为外部函数的执行已经结束了，它的变量对象里面的a变量一般情况下应该会被销毁。可是它还被其他函数引用，所以浏览器的js引擎并不会销毁它，js引擎可是很有人情味的。所以这个a还一直呆在内存里面，可以通过f函数来访问它。这样的函数f我们就可以称它为闭包了。

我们也不能因为闭包好像很牛b的样子而滥用它，因为该清理的内存还是应该要清理掉的。

闭包有什么用处呢？前面已经讲过了，其实就是为了在外部访问局部作用域里面的变量,通过它我们可以实现私有变量：

<pre>
<code>
function Obj(){
  var a = 0;
  this.get = function(){return a};
  this.set = function(v){a = v;};
}
var o = new Obj();
</code>
</pre>

Obj通过new调用，返回了一个对象，这个对象有两个函数引用了Obj里面的a变量，其实也就是相当于返回了两个引用了a变量的函数，形成了闭包，通过这两个函数，我们可以访问这个变量a与设置它。这样就和私有变量作用一样了。

最后再讲一个被讲烂的例子吧：

<pre>
<code>
document.body.onclick = function(){
  for (var i = 0; i < 3; i++){
    setTimeout(function(){console.log(i);},100);
  }
}
// 输出 3，3，3
</code>
</pre>

为了搞点事情，我们不立即执行console.log，而是用定时器来延迟执行，这样的话，在定时器里的匿名函数引用了i，所以形成了闭包。这三个函数都是引用同一个变量，那就是i，而i在上面代码执行后，没有被销毁，值为3，所以三个函数都会输出3。

再次利用闭包解决问题：

<pre>
<code>
document.body.onclick = function(){
  for (var i = 0; i < 3; i++){
    setTimeout(function(a){console.log(a);}(i),100);
  }
}
// 输出 0，1，2
</code>
</pre>

上面的代码也形成了闭包，不过和之前不同的是它们引用的i不同了。通过参数传递，新建的三个形参a都是由实参i得到的，但是它们有新的存储空间，与i是没有关系的，所以最后i变成了3也影响不了三个函数的形参a。

通过上面两个例子，应该可以简单理解闭包是什么东西了。
