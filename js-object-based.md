## JS重要概念之面向对象

>最近想熟悉一下js的一些基础但是非常重要的概念，包括面向对象、this、作用域、闭包等等。这是这个系列的第一篇。

我是先学**c++** 再学**js** 的，对面向对象也有一定的了解。不过**js** 的面向对象的编程却不是那么系统，比如说继承我就总感觉它是通过一些小技巧来达到的。下面我们就通过对象的创建，对象的属性和对象继承来了解一下**js** 面向对象的编程吧。

### 对象的创建

首先呢我们可以通过**对象字面量** 的方式创建一个对象（如果不觉得麻烦的话）：

<pre>
<code>
var obj = {name: 'js', color: 'blue'}
</code>
</pre>

不过这样可实现不了代码的复用，写多了就觉得挺麻烦的。所以我们还有一些两种方式。

构造函数方式：

<pre>
<code>
function Obj(){
  var a = 1;
  this.b = 2;
}
var obj = new Obj();
</code>
</pre>

工厂方式：

<pre>
<code>
function Obj(){
  var obj = new Object();
  obj.b = 2;
  return obj;
}
var obj = Obj();
</code>
</pre>

构造函数方式应该是比较正宗的方法，工厂方式与构造函数方式有一下不同点：
1. 构造函数方式隐式创建对象，隐式返回该对象的引用，即**this**，我们在以后的章节回去了解它。
2. 在上面的工厂方式的我没有定义私有变量a，因为我也不知道怎么定义它啊。即工厂方式无法定义私有属性与原型属性。而构造函数方式是可以的。
3. 使用方法不同，构造函数方式使用**new** 来创建对象，工厂方式与普通函数调用是一样的。

所以说哪种方式比较好那是显而易见的事情了。

### 对象的属性
我们来看对象可以定义哪些属性（方法与属性是差不多的，所以这里只讨论属性）：

<pre>
<code>
function Obj(){
  var a = 1; //私有属性
  this.get = function(){return a}
  this.b = 2; //实例属性
}
Obj.prototype.c = 3; //原型属性
Obj.d = 4; //类属性（构造函数的属性）
var obj = new Obj();
obj.e = 5; //动态属性
</code>
</pre>

好多属性啊，比我学的**c++** 的class还要多好多。我觉得并不能完全按照学习其他语言的方式来理解这些属性，因为这些东西好像是**js** 使用一些小技巧来模拟别人面向对象的东西。不过我们可以从两方面来理解它们：
1. 为什么需要它？
2. 怎么实现它？

#### 实例属性与动态属性

这两个应该比较好理解，就是实现公有属性的功能，可以被外界访问到。不过实例属性是每一个新建对象都具有的公有属性，而动态属性是只有一个实例才拥有的（这些属性的名字你想怎么命名都可以，因为区分我们的不是我们的名字）。

#### 原型属性

我们需要继承怎么办？所以我们就拥有了原型属性，它可以用来实现继承（后面章节我们可以学习到）。那它到底是什么东西呢（怎么实现的呢）？原型是一个对象，构造函数有一个**prototype** 属性指向它，而一个实例对象也有一个\_\_proto\_\_属性指向于它。而当我们的实例中搜索不到一个属性时会去搜索它的原型，再搜索不到的话会继续寻找原型的原型。而我们可以通过构造函数的**prototype** 属性来修改原型的属性。除了继承的功能，原型还实现了静态属性的功能（所有实例的原型都是一个对象，共享这些属性）。

#### 私有属性

我们需要一个不能被外界访问的属性，所以我们实现一个私有属性。但是现在实现的私有变量只能被实例属性方法访问，不能被其他属性访问，所以实例方法又可以称作特权方法。那为什么会这样呢？这就牵扯到私有属性的实现方式了。

我觉得私有属性应该是使用了比较有技术含量的技巧了，那就是**闭包**（以后再详细讲）。它需要一个get或者set方法（特权方法）来访问它，如果没有，则在new调用之后，它就被回收了（因为它是属于构造函数里面的变量，函数调用完毕后它就消失了）。不过如果构造函数返回了一个方法会访问到这个变量，就形成了闭包，它就不会被回收了。所以我定义了一个get方法，因为返回了一个对象，这个对象有一个get方法，实际也可以认为返回了一个访问了私有变量的get方法，所以形成了闭包。所以这就模拟了私有变量，我们还可以定义一个set方法来修改它。

#### 类属性

类属性其实在原型属性里面已经可以说实现了，我也不清楚为什么还需要这样实现（其实可能是要这样理解：不是要实现，而应该是本来就有的东西不用白不用嘛）。它其实是构造函数的属性，因为所有东西在**js** 中都是对象。和**prototype** 其实也是差不多的，不过是没有实例对象的属性指向它而已罢了。

它的访问方式和**c++** 的类属性访问差不多，可能更好让别人理解这是类的属性吧。

###  对象的继承

**js** 的继承真的是不可思议，感觉就像非常聪明的人创造出来的。

我们可以从继承了什么属性来将这些继承方式来分类，可以将它们分为三类：
1. 继承实例属性。
2. 继承原型属性。
3. 继承原型属性与实例属性。

#### 第一种方法

首先第一种方法我们用**apply** 实现：

<pre>
<code>
function Parent(a){
  this.p = a;
}
function Child(a){
  Parent.apply(this,[a]);
}
</code>
</pre>

这实际上用**this** 冒充了**Parent** 的**this** 将所有父类的所有用**this** 定义的属性都复制给子类了（其实就是实例属性）。除了这种方法，还有其他许多能够实现同样效果的方法，比如**call** 函数实现等等，它们都可以归为这一类。下面这个方法也是可以的：

<pre>
<code>
function Parent(a){
  this.p = a;
}
function Child(a){
  this.Par = Parent;
  this.Par(a);
  delete this.Par;
}
</code>
</pre>

#### 第二种方法

<pre>
<code>
function Parent(){}
function Child(){}
Child.prototype = Parent.prototype;
</code>
</pre>

其实就是将父类的原型对象赋值给子类对象原型，然后子类对象就拥有了父类的原型的属性。实际上我们在使用**new** 创建一个对象的时候，也是这样继承了**Object**的原型。不过这样我们修改了Child的原型也会修改Parent的原型，是一个很大的缺陷。

#### 第三种方法

<pre>
<code>
function Parent(){}
function Child(){}
Child.prototype = new Parent();
</code>
</pre>

这实际上将父类的实例赋给了子类对象的原型上面，这样就可以访问到父类的实例属性与原型属性了。不过虽然是显示调用了Parent构造函数，可是这是在构造函数外面调用的，无法传递参数给父类构造函数，而第一种方法是可以传递参数的。

剩下的就是将这几种方式组合起来，取其精华去其糟粕了。其实最重要的应该先掌握以上几种最基础的继承方式，其他方法也可以应对了。

