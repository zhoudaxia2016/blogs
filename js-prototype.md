## JS重要的基础概念之原型

>常常听说**JS** 有一个叫做**原型** 的东西，实在是令人头大，所以这次我要深入探究一下**原型** 到底是何物，有什么用处。本文是**JS重要基础概念** 系列的第二篇文章，第一篇地址为[JS重要的基础概念之对象](http://maozzhou.cn/detail/12)。该系列文章主要目的是为了探究**JS** 最基础的概念，也是进阶学习的必须理解的概念。

本文通过介绍原型对象，**new** 操作符，原型链的顺序来展开。

### 原型对象

每一个实例对象都有一个属于它的原型对象（除了Object.prototype)，通过它，我们可以设置一些静态属性（即同一个类的所有实例共享的属性），还可以通过它来实现继承。在**firefox** 我们可以通过属性 \_\_proto\_\_ 来引用这个原型对象。

那这个东西从哪而来？答案是从**函数对象**。**JS** 的对象可以分为函数对象与普通对象，只有函数对象具有一个属性**prototype** ，它指向该函数对象的原型对象，下节我们来讲函数对象的原型对象是如何成为实例对象的原型对象的。

### new操作符

**new** 操作符一共做了三件事情：
1. 创建一个空对象。
2. 将空对象的的原型指向构造函数的原型对象。
3. 使用该空对象调用构造函数，然后返回它的引用。

即这个新建立的对象的\_\_proto\_\_指向了构造函数的**prototype**。所以我们经常这样来修改实例的原型对象（即修改构造函数的**prototype**):

<pre>
<code>
function Foo(){}
Foo.prototype.a = 1;
var foo = new Foo();
console.log(foo.a);
</code>
</pre>

这样一个类的所有实例就能共享构造函数的原型对象上的属性，实现了静态属性的功能。

### 原型链

终于到了最最重要与难以理解的地方了。当我们查找对象的属性的时候，它是怎么找的呢？首先会去搜索对象实例上的属性，然后搜索实例的原型对象，然后查找原型对象的原型对象，最后肯定会到到**Object.prototype**，然后就停止了（因为**Object.prototype** 的原型对象为**null** )。当一找到该属性也会停止搜索。而原型的原型这样的结构就是一条原型链。

我们可以从下面的例子详细了解：

<pre>
<code>
function Obj(){
  this.a = 1;
}
Obj.prototype.b = 2;
Object.prototype.c = 3;
var obj = new Obj();
console.log(obj.a,obj.b,obj.c); //输出：1，2，3
</code>
</pre>

上面例子的属性查找顺序为：obj,Obj.prototype,Object.prototype。因为Obj.prototype是由Object构造出来的，所以它的原型对象为Object.prototype。

### 一些疑问

普通对象的原型链我觉得是非常好理解的，最终肯定会搜索到**Object.prototype** 然后就停止了嘛。而函数对象的原型链就有点难以理解了。其他函数都是又Function构造的，而Function又是对象，它是Object构造的。而Object也是一个函数对象，它应该是由Function构造的。这就很像一个先有鸡还是先又蛋的问题了。

我暂时还没有能力提供这个问题的解答，不过可以从[这个帖子](http://bbs.csdn.net/topics/390772104)的回答让大家有所领悟。

最后这个检测也更加印证了那个帖子的回答(不是我举的例子，是那个帖子的回答里转来的）：

<pre>
<code>
Object.prototype  instanceof Object; // false
</code>
</pre>
